首先需要了解一下几种在不加干预的情况下并发事务会出现的问题

1.脏读
一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；
这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些"脏"数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。
这种现象被形象的叫作"脏读"（Dirty Reads）

2.不可重复读
一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！
这种现象就叫作"不可重复读"（Non-Repeatable Reads）。
不可重复读和脏读的区别在于，脏读是读取了另一个事务未提交的修改，而不可重复读是读取了另一个事务提交之后的修改，本质上都是其他事务的修改影响了本事务的读取。

3.幻读
当同一个查询在不同的时间产生不同的行集时，就会出现所谓的幻像问题。从文档来看幻读的问题在于数据集不在于记录自身的内容，所以insert和delete操作才会导致幻读。
幻读和不可重复读的区别在于，后者是两次读取同一条记录，得到不一样的结果；而前者是两次读取同一个范围内的记录，得到不一样的记录数（严格点的说法应该是：两次读取得到的结果集不一样）。
不可重复读是因为其他事务进行了UPDATE操作，幻读是因为其他事务进行了INSERT或者DELETE操作。

隔离级别
安全和性能的取舍
四种不同的隔离级别：
读未提交（Read Uncommitted）：可以读取未提交的记录，会出现脏读，幻读，不可重复读，所有并发问题都可能遇到。
读已提交（Read Committed）：事务中只能看到已提交的修改，不会出现脏读现象，但是会出现不可重复读、幻读；（大多数数据库的默认隔离级别都是RC，但是InnoDB默认是RR）。
可重复读（Repeatable Read）：InnoDB默认的隔离级别，解决了不可重复读和幻读。（标准情况下，在RR隔离级别下能解决不可重复读（行修改）的问题，但是不解决幻读的问题，MySQL Innodb的实现有差异可以解决幻读）。
序列化（Serializable）：最高隔离级别，没有并发问题。

隔离级别和事务
锁
无锁：时间戳，多版本控制等。

锁的模式
共享锁：多个事务可以一起读，共享锁之间不互斥，共享锁会阻塞排它锁
排它锁：允许获得排他锁的事务更新数据，阻止其他事务获取共享锁和排他锁。
锁的类型
表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。
记录锁 是最简单的行锁。记录锁永远都是加在索引上的，就算一个表没有建索引，数据库也会隐式的创建一个索引。
如果 SQL 语句无法使用索引时会走主索引实现全表扫描，这个时候 MySQL 会给整张表的所有数据行加记录锁。如果一个 WHERE 条件无法通过索引快速过滤，存储引擎层面就会将所有记录加锁后返回，
再由 MySQL Server 层进行过滤。不过在实际使用过程中，MySQL 做了一些改进，在 MySQL Server 层进行过滤的时候，如果发现不满足，会调用 unlock_row 方法，把不满足条件的记录释放锁
（显然这违背了二段锁协议）。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。
可见在没有索引时，不仅会消耗大量的锁资源，增加数据库的开销，而且极大的降低了数据库的并发性能，所以说，更新操作一定要记得走索引。

Multi-Version Concurrent Control（多版本并发控制）
InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的删除时间。
当然存储的并不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询的每行记录版本号进行比较。



